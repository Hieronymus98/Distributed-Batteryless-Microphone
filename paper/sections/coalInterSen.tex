\fullsys (\sys) is the abstraction of a group of batteryless intermittent sensors. \sys seeks to offer continuous sensing despite relying on ambient energy: an unpredictable and marginal power source. 
%orchestrates its nodes power cycles using a distributed approach (instead of relying on a master powerful node to coordinate coalesced nodes activities). 
%\sys seeks maximum time span of its underlying coalesced nodes through a distributed approach instead of a master node that orchestrates coalesced nodes on/off cycles. 

\subsection{Energy consumption}
%
\begin{figure}[t]
	\centering
		\begin{subfigure}{\columnwidth}
			\includegraphics[width=\columnwidth]{figures/PowerCycleIntermittentSystem}
			\caption{When \sys does polling-based sensing, its energy consumption profile has, generally, two distinct rates: zero when it is charging, and a maximum when it is sensing.}
			\label{fig:pollingBasedSensing}
	\end{subfigure}
	\begin{subfigure}{\columnwidth}
		\includegraphics[width=\columnwidth]{figures/PowerCycleIntermittentSensor}
		\caption{When \sys does event-based sensing---staying in low power mode listening for an external event to happen---, its energy consumption profile has three distinct rates: zero when it is charging, a maximum when it is sensing, and an in-between energy consumption rate when it is listening. The third rate requires special attention when designing a \sys.}
		\label{fig:eventBasedSensing}
\end{subfigure}
		\caption{\fullsys energy profile for different sensing strategies. Green bars highlight successful sensing operations  while the red bar shows a failed sensing attempt due to insufficient buffered energy.}
		\label{fig:cisPwrCycle}
\end{figure} 
%
An intermittent sensor has a limited energy budget per power cycle. When it is tasked with a polling-based sensing activity, its energy consumption, generally, switches between two levels: zero when charging and a maximum when it activates its microcontroller for data acquisition and processing, (see Figure~\ref{fig:pollingBasedSensing})---we assume that the microcontroller is the dominant energy consumer module of a node. However, in event-based sensing, a node puts its microcontroller into low power mode and waits (or listen) for an external event to wake up the microcontroller. This is important to minimize the energy wasted on the listening and to maintain the required energy budget for sensing for the longest possible time (Figure~\ref{fig:eventBasedSensing}). The idle listening mode, which is important for successful sensing, complicates the design of the \sys.

\subsection{Availability}
\label{subSec:availability}
%
\begin{figure}[t]
		\centering
		\includegraphics[width=\columnwidth]{figures/cisOntime}
		\caption{\fullsys's on-time is the projection of its intermittent nodes uptimes on the time axis. When the power cycles of the intermittent nodes are different their uptimes distribution approaches uniform distribution. The red bars indicate a minimum \cim time span---\cim's nodes are overlapping---whereas the green bars show the maximum time span of the \cim.}
		\label{fig:cisOntime}
\end{figure} 
%
The \sys's on-time is the projection of its underlying intermittent nodes' uptimes on the time axis. The \sys's on-time ranges from minimum (when all nodes on-times cluster together, see the red regions in Figure~\ref{fig:cisOntime}) to the maximum (when the overlapping between its nodes uptimes is zero or when the continuous time is reached). Two broad controlling strategies for minimizing nodes on-times overlapping and maximizing \sys's time span can be imagined: 
\begin{enumerate}[label=\roman*.]%[wide, labelwidth=!, labelindent=0pt]
%
		\item \textit{Explicit on-time division strategy}: Recent advancements in timing intermittent operations enable intermittent nodes to measure their on and off times with the help of an external ultra-low-power timer~\cite{mayfly2017hester}. Similar breakthroughs in passive communication enable ultra-low-power message exchange between batteryless nodes~\cite{marco}. Intermittent nodes can use these recent advancements to apply time division multiplexing strategy to explicitly avoid nodes on-times clustering. For example, a node calculates its average on-time $\overline{t_{on}}$ and off-time $\overline{t_{off}}$ for $N$ power cycles. Then it measures the time difference between its power-up and the intended transmitting time $\Delta\,t$. Then it encodes these information $({\overline{t_{off}}, \overline{t_{on}}, \Delta\,t})$ in a message and broadcasts it. If a node receives this message it will have full information about the transmitting node power cycle. It can then alter its power cycle, relative to the transmitting nodes cycle, by either increasing (or decreasing) its power consumption to shorten (or lengthen) its on-time and shift its power cycle to a different time slot. This approach, obviously, assumes relatively stable nodes power cycles. 
%
\begin{figure}
		\centering
		\includegraphics[width=\columnwidth]{figures/cisModel}
		\caption{\fullsys availability percentage for a different number of nodes and different duty cycles. The nodes are uniformly distributed and the \sys on-time evolves according to the equation~\ref{eq:cisModel} when new nodes are added.}
		\label{fig:cisModel}
\end{figure} 
%
		\item \textit{Implicit on-time division strategy}: With no information being exchanged between intermittent nodes, the best \sys can do is to uniformly distribute its node's on-times and maintaining this distribution over time. The key observation to uniformly distribute the nodes' on-times is to ensure that their power cycles are different. This can be achieved by forcing intermittent nodes to go into low-power-mode upon power-ups. The length of this mode is randomly chosen for each node. This will change the length of the nodes on-times and, consequently, alter their power cycles. Figure~\ref{fig:cisOntime} shows the scenario of two intermittent nodes with different power cycles. Node 1 has a power cycle of 6 units of time and an on/off cycle of $\frac{1}{3}$. Node 2 has a power cycle of 5 units of time and an on/off cycle of $\frac{1}{5}$. Following the time axis from the left, we can see that the position of the on-time of Node 2 is shifted by 1 unit of time after each power cycle of Node 2. This implies that the on-times of the two nodes are $\frac{1}{3}$ of the time cluster together and $\frac{2}{3}$ of the time they are apart. If we extend the previous scenario to three or more nodes then the on-time of the resulting \sys can be described with the following formula,
				
\begin{equation}
	t_{on}(N) = t_{on}(N-1) + \frac{t_{off}(N-1)}{t_{off}(N-1)+t_{on}(N-1)} \times t_{on}(1),
		\label{eq:cisModel}
\end{equation}
where $t_{on}(N)$ is the on-time of a \sys with $N$ intermittent nodes. Figure~\ref{fig:cisModel} shows the \sys availability percentage for different duty cycles and different number of intermittent nodes.
\end{enumerate}
There is a clear trade-off between the aforementioned methods. While the explicit control method provides fine control over the system distribution, the implicit method does not suffer from control messages exchange overhead. Although the implicit method is relatively simple to implement and explore, the explicit control method is not a far fetched idea considering the recent advancements in passive communication and intermittent timing. However, we opt to explore the implicit distribution control method as the hardware used to demonstrate the feasibility of passive light communication and ambient RF backscattering are not open source and re-making it is beyond the scope of this study.

\subsection{Intermittent Timer}
\label{subsec:interTimer}
Timing is a key building block for sensing activities. However, it is missing on intermittent nodes, unless additional dedicated timer circuit is added to the intermittent nodes~\cite{hester2017timely}. Here we would like to propose an alternative way the does not require additional timer hardware. Obviously, the on-time of a node can be measured using the build-in timers in the microcontroller. However, the difficulty is \textit{how an intermittent node can time its own off-time?}. Actually, answering this question does not only enable timing on intermittent devices, but it can also be used as a metric to estimate the environment energy richness. \todo{Also, it can be used to estimate how much energy is left in the buffer when power consumption is relatively stable.}

\paragraph{Timing the death} 
Algorithm~\ref{algo:offTime} shows how a node can estimate its off-time. The high level idea is that a node measures its on-time (Line~\ref{lin:ontime}) and compares it a reference time. The additional $\Delta{t}$ is caused due to harvested energy while executing (Line~\ref{lin:deltat}). By assuming a relatively stable charging rate, a node can calculate how long it will be off charging (Line~\ref{lin:ehar}-\ref{lin:offtime}). Obviously, in order for the time estimation to be correct, the reference time and the on-time measurement must be done with same load.
% off-time estimation 
\begin{algorithm}[t]
	\captionof{algorithm}{off-time estimation}
    \label{algo:offTime}
    \small
    \begin{algorithmic}[1]
		\State \Call{$f_\text{reboot}$}{$u$} $= u{+}{+}$ \Comment{power reboot counter}
		\State $i \leftarrow $ \Call{$f_\text{reboot}$}{$i$} \Comment{$i$ is persistent variable}
		\State $E_\text{buf}$ \Comment{Size of energy buffer}
		\State $t_a$ \Comment{time of discharging $E_\text{buf}$ at load $a$, no harvesting}
		\State$ t_{i} \leftarrow x $ \Comment{timing every $x$ power cycles}
		%
		\If{$(i\mod t_{i})=0$}
		    \State $i=0$
			\State \Call{$f_\text{load}$}{$a$} \Comment{set node load to $a$ }
			\State \label{lin:ontime} $t_\text{on} \leftarrow$ \Call{$t_\text{pers}$}{\null} \Comment{persistent infinite loop}
		\EndIf
		\If{$i=0$}
			\State \label{lin:deltat}$\Delta{t} = t_\text{on}-t_a$  \Comment{time difference due to charging}
			\State \label{lin:ehar}$E_\text{har} \leftarrow (E_\text{buf}\div t_a)\times\Delta{t}$ \Comment{harvested energy}
			\State $P_\text{in} \leftarrow E_\text{har}\times{t_\text{on}}$ \Comment{incoming power}
			\State \label{lin:offtime}$t_\text{off} \leftarrow E_\text{buf}\div P_\text{in}$
		\EndIf
	\end{algorithmic}
\end{algorithm}

\subsection{Power States}
A \sys can experience a wide range of ambient power intensity. For example, a solar-powered \sys may harvest no energy at night, modest energy from artificial light, and much more from direct sunlight.  Generally, we can identify four different \sys powering states: 
\begin{enumerate}
		\item \textit{Targeted energy conditions}---These are the energy conditions that the \sys designed for. In these energy conditions, the \sys should work intermittently and have sufficient power cycles randomness to uniformly distribute its intermittent nodes on-times and meet the desired availability percentage~\ref{fig:cisModel}. In general, the targeted energy conditions should be near worst energy harvesting conditions to ensure that the system is properly functioning for the majority of the time.
		\item \textit{Under-targeted energy conditions}---Ultimately, the ambient energy is an uncontrollable power source, and it is not hard to imagine scenarios where a \sys will be under-powered or even comes to complete and long power down (for example, a solar \sys will come to a perpetual power down in the darkness). In general, for under-targeted energy conditions, the \sys behavior can be considered as undefined.
%
\begin{figure}
		\centering
		\includegraphics[width=\columnwidth]{figures/noRandomization}
		\caption{\todo{Placeholder} No randomization}
		\label{fig:noRand}
\end{figure} 
%
		\item \label{it:hibernating} \textit{Hibernating energy conditions}---when \sys is tasked with event-based sensing, and the energy conditions are relatively higher than the targeted conditions, then the harvested energy may compensate for the energy consumption of the low-power mode. Thus, the system loses its randomness feature, and all the nodes will react to the first external event and power down shortly after as the energy consumption of sensing and processing is much higher than the energy consumption of the low-power-mode idle listening. If the external events happened to be sporadic, then this is not a big issue. However, for a bursty type of events (i.e. a command of two or three words), this will prevent the \sys from meeting its goal: continuous sensing (Figure~\ref{fig:noRand}). 
		\item \label{it:continuous} \textit{Continuously powered}---Under direct mid-noon sun even a tiny solar panel can continuously power a sensor. In such conditions, the \sys will sense continuously without the need for randomization. Therefore, the job of a single node will be repeated $N$ times, and instead of sending a single message to a battery-powered or tethered sink---to push the data to the internet---$N$ identical messages will be sent which waste a lot of energy. 
				
\end{enumerate}
%
\begin{figure}
		\centering
		\includegraphics[width=\columnwidth]{figures/randomization}
		\caption{\todo{Placeholder} Randomization}
		\label{fig:rand}
\end{figure} 
%
\begin{figure}
		\centering
		\includegraphics[width=\columnwidth]{figures/randomizationSideEffect}
		\caption{\todo{Placeholder} Randomization side effect}
		\label{fig:randSideEffect}
\end{figure} 
%
The problems mentioned in~(\ref{it:hibernating}) and (\ref{it:continuous}) can be mitigated by enforcing randomization on the response of the intermittent nodes (Figure~\ref{fig:rand}): when a node is wakened up by an external event it responds to that event with a certain probability. However, if the randomized response is enforced all the time, then the \sys will have a lower probability of catching events during the targeted energy conditions (Figure~\ref{fig:randSideEffect}). Therefore, the \sys has to distinguish between the targeted and above-targeted energy conditions and apply response randomization only during the above-targeted energy conditions. Moreover, choosing a fix response probability is an inefficient way of dealing with the over-powering problem. As the number of active intermittent nodes at a given moment in time is a function of the total number of nodes and the power intensity at that time. To this end, an intermittent node has to estimate the number of active nodes at the external event occurrence moment, which is discuss it next.

\subsection{Nodes overlapping}
In order for a node to estimate the number of active nodes at a given moment, first, it has to know the total number of nodes ($N$) in its \sys, which we assume to be known to the nodes before deployment. Second, this analysis is built on the observation that a node's on and off times is a good indicator about the on and off times of other nodes in the \sys (Figure~\ref{support this observation}). A node can measure its on-time $t_\text{on}$ and off-time $t_\text{off}$ using  Algorithm~\ref{algo:offTime} (or an external dedicated timer~\cite{hester2017timely}). Then, it can estimate the maximum time span ($t_{max}$) of its \sys, which is the total duration of the nodes' on-times when they are aligned next to each other as follows,
$$
t_\text{max} = N\times t_\text{on}
$$
 and approximate the time of the \sys power cycle to be the sum of its on and off times,
$$
t_\text{pwr} = t_\text{on} + t_\text{off}.
$$
Then, from equation~\ref{eq:cisModel}, the node calculates the \sys availability percentage or the \sys spreading factor ($f_\text{spread}$). After that, the node computes the total overlapping on-time ($t_\text{ovr}$) of the \sys as follows,
$$
t_\text{ovr} = (1-f_\text{spread})\times t_\text{max}.
$$
As we have argued in Section~\ref{subSec:availability}, nodes on-times are uniformly distributed over the \sys power cycle. Similarly, the $t_\text{ovr}$ is also uniformly distributed over the \sys power cycle. Thus, a node can calculate the average number of active intermittent nodes using the following formula,
$$
n_\text{active}=\lceil{t_\text{ovr}\div t_\text{pwr}}\rceil,
$$
and make the educated guess for the proper randomization factor. If a second event, however, happens shortly after the first one, a node needs to update $N$ by subtracting $n_\text{active}$ and redo the calculation. 